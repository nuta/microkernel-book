# 実験テーマのアイデア集

このページでは、HinaOSの実験テーマのアイデアを紹介します。HinaOSを元に自分のOSを作って遊びながら、OSの仕組みを学んでみましょう。

## 難易度: 低 ★☆☆

### ページフォルトの観察

タスクがマップされていないメモリページにアクセスすると、カーネルのページフォルトハンドラが呼び出され、VMサーバにメッセージが送信されます。HinaOSでは、起動時にカーネル用を除くページはどこもマップされていません。そのため、ページフォルトハンドラを使って「タスクが実際に利用するメモリ領域はどこか」を観察することができます。

カーネルのページフォルトハンドラ (`handle_page_fault` 関数) に、`TRACE`マクロを追加して、どのアドレスにアクセスがあったかを表示し、どのような特徴があるのかを観察してみましょう。各タスクの実行ファイルは300KB以上ありますが、実際に読み込まれる部分はどれくらいなのか、「参照の局所性」という言葉と関連付けて考えてみるとよいでしょう。

余力のある方は、`TRACE`マクロの出力を整形し、Python (matplotlibライブラリなど) を使って可視化してみるとより分かりやすいでしょう。

### プリページングの実装

HinaOSでは、タスクの各ページは必要になるまでマップされません。いわゆる「デマンドページング」です。プリページング (Pre-paging) はその逆で、タスクの各ページを事前にマップしておくことで、ページフォルト処理による遅延を減らすテクニックです。

プリページングを実装してみましょう。おそらく、VMサーバのタスクを起動する処理の中に、ページをマップする処理を追加することになるでしょう。ただし、全ページをマップするとかえって遅くなるため、どのページをマップするかを工夫する必要があります。例えば、次のような方法が考えられます。

- タスクのエントリポイントの近くの実行可能ページをマップする。
- スタック領域は事前にある程度マップする。
- 前回の実行時にアクセスしたページを記録し、次回の実行時にそれをマップする。

### 新しいサーバの実装

新しいサーバを追加してみましょう。たとえばクライアントから処理要求を受け取ると、ジョークを返すサーバを実装してみると楽しいでしょう。

サーバの実装は以下の手順で行います。

1. `messages.idl`に新しいメッセージを定義し、一回 `make` を実行してメッセージの型定義を自動生成する。
2. `servers`ディレクトリに新しいサーバのディレクトリを作成する (`servers/pong`をコピーアンドペーストするとよい)。
3. サーバの実装を書く。
3. Makefileの`BOOT_SERVERS`変数に新しいサーバを追加する。すると、起動時に自動的にサーバが起動するようになる。
4. クライアント側の実装を書く。たとえばコマンドラインシェルにサーバと通信する新しいコマンドを追加する。

### システムコールの追加

システムコールを追加してみましょう。たとえば「割り込みの発生回数」といった統計情報を取得するシステムコールを追加してみましょう。コマンドラインシェルから確認できるようにしてみると、数字がどんどん増えていくのが見られて面白いでしょう。

### セキュリティ機構の実装

HinaOSカーネルはサーバとアプリケーションを区別せず、どのユーザータスクでも物理メモリのマップといった危険な操作ができるようになっています。また、メッセージパッシングの通信相手や通信内容 (メッセージの種類) についても制限がありません。そこで、OSを堅牢にするための次のような機構を実装してみましょう。

- 各タスクが実行できるシステムコールを制限する。
- タスクが送信できるメッセージの種類を制限する。
- 制限内容を設定するためのシステムコールを実装する。

タスク自身が権限を放棄し、制限を自ら設定できるようにしても面白いでしょう。また、HinaVMを活用した柔軟なアクセス制御機構を作ってみるのも楽しそうです。

OpenBSDのpledgeなど、ちまたのOSのセキュリティ機構も参考になります。

### スケジューリングアルゴリズムの実装

HinaOSカーネルは素朴なラウンドロビン方式のスケジューリングしか実装していません。新たにスケジューリングアルゴリズムを実装してみましょう。たとえば、優先度スケジューリングを実装するには、次のような変更が必要です。

- カーネルのタスク管理構造体に優先度フィールドを追加する。
- 優先度を変更するシステムコールを実装する。
- カーネルのスケジューラ関数を変更する。

上手く動いているかを確認するには、次のようなプログラムを実行してみるとよいでしょう。
「A」を出力するタスクと「B」を出力するタスクを作り、スケジューリングアルゴリズムによって、出力される文字数の割合が変わるはずです（たとえば優先度の高い「A」がずっと出力される）。

```c
void main(void) {
    for (;;) {
        printf("A"); // "B" を出力するプログラムも作っておく

        // 出力が多すぎないように、少し待つ
        for (unsigned i = 0; i < 1000000; i++) {
            asm volatile ("");
        }
    }
}
```

## 難易度: 中 ★★☆

### HTTPサーバの実装

簡単のため、HinaOSにはTCPのクライアント側実装しかありません。TCP実装の不足している部分を付け足して、HTTPサーバのアプリケーションを実装してみましょう。自作OSから送られたHTMLをWebブラウザ上で表示できると、飛び上がるほどの喜びが得られます。

なお、HinaOSのWebサーバにアクセスするには、QEMUの `hostfwd` オプションを指定すると便利です。たとえば`hostfwd=tcp:127.0.0.1:1234-:80`と設定すると、開発機の1234番ポートにアクセスすると、HinaOSの80番ポートに転送されます。

また、適当なサーバ上でQEMUを動かして、HinaOSのWebサーバにインターネットからアクセスできるようにしてみると感動できます。

### デバイスドライバの実装

QEMUのvirtマシンには「Google Goldfish RTC」という、仮想的なリアルタイムクロック (RTC) デバイスが繋がっています。現在時刻を提供するデバイスです。

[Goldfish RTCのドキュメント](https://android.googlesource.com/platform/external/qemu/+/master/docs/GOLDFISH-VIRTUAL-HARDWARE.TXT)を参考に、デバ
イスドライバを実装し、現在時刻を表示してみましょう。

### 組み込み向けインタプリタの移植

インタプリタを移植して、C言語以外のプログラミング言語でアプリケーションを書いてみましょう。とはいえ、CPythonのような大規模なインタプリタを移植するのは大変です。そこで使えるのが、組み込みソフトウェア向けの軽量なインタプリタです。移植性が高いため、そこまで大変ではありません。

たとえば、次のようなインタプリタがあります。未検証ですが、JerryScriptは移植が比較的簡単そうです。

- [QuickJS](https://bellard.org/quickjs/) (JavaScript)
- [JerryScript](https://jerryscript.net/) (JavaScript)
- [mruby/c](https://www.s-itoc.jp/support/technical-support/mrubyc/) (Ruby)
- [MicroPython](https://docs.micropython.org/en/latest/develop/porting.html) (Python)
- [Lua](https://www.lua.org/about.html) (Lua)

移植するには、次のような作業が必要です。

- C言語標準ライブラリの移植 (Newlibなど)。`stdio.h` といった機能に依存していることが多いため。
- インタプリタをHinaOS内でビルドできるようにする (コンパイラオプションの調整)。
- インタプリタを起動するプログラムを作成する。`servers/shell`に埋め込むと楽かもしれない。

### SQLiteサーバ

SQLiteは軽量な関係データベース管理システム (RDBMS) です。実はSQLiteは[移植性が非常に高く](https://www.sqlite.org/custombuild.html)、HinaOSでも比較的簡単に動かすことができるでしょう。

HinaFSの代替として、SQLiteベースのデータベースサーバを実装してみましょう。

[`sqlite3`ブランチ](https://github.com/nuta/microkernel-book/tree/sqlite3#sqlite3-on-hinaos) に実装例が置いてあります。

### 自動サーバ再起動機能の実装

サーバがクラッシュしたときに、自動的に再起動する機能を実装してみましょう。ユーザータスクが異常終了する際にはVMサーバにメッセージが届くので、その情報を元に再起動を行うと良いでしょう。

ただし、再起動するだけでは不十分です。HinaOSのユーザータスクたちは、起動時に一度だけ`ipc_lookup`関数を呼び出して通信相手を検索します。そのため、再起動した場合はタスクIDを再び探し直すようにしなければなりません。

### 脆弱性を見つけよう

本の中では、virtio-netとHinaVMの2つの脆弱性を紹介しています。これらの他にも、HinaOSには脆弱性が存在します。脆弱性を実証するプログラムを作成し、脆弱性をどう防ぐべきかを考え、修正してみましょう。

### 共有メモリの実装

メッセージパッシング以外のプロセス間通信 (IPC) として、共有メモリを実装してみましょう。既存のシステムコールを上手く使えば、VMサーバ上で実装できるはずです。

## 難易度: 高 ★★★

### GUIの実装

HinaOSはコマンドラインシェルを実装しています。ただし、文字を表示したり色や装飾をつけたりするのはHinaOSではなく、シリアルポート経由で接続された開発OSのアプリケーション (macOSだとTerminal.appなど) が描画しています。

文字ではなくマウスポインタやウィンドウといった画面を描画できると、自分のOSを作っている感覚がぐんと高まります。また、ウィンドウシステムを愚直に実装すると、画面のちらつきやマウス操作の遅延といった問題が発生しやすいため、描画処理の最適化を考えるのがまた面白いです。

画面描画には当然画面に繋がるデバイス、キーボード・マウス入力をつかさどるデバイス、そして制御するデバイスドライバが必要です。未検証ですが、QEMUのオプション (`QEMUFLAGS`) に `-device virtio-gpu-device,bus=virtio-mmio-bus.2` を追加すれば、virtio-gpu経由で画面描画ができるはずです。入力デバイスについてもvirtio-inputが使えるはずです。

GUIをゼロから作るといわれてもイメージがつかないと思います。そんな方は[MikanOS](https://zero.osdev.jp/)が参考になるでしょう。x86-64 CPUの勉強もできて一石二鳥です。また、[Wayland](https://wayland-book.com/)や[X Window System](https://wayland-book.com/)の仕組みを調べるのもおすすめです。

### Rust/Zig/C++でHinaOSを再実装

HinaOSはC言語で実装されていますが、もちろん他のプログラミング言語でもOSを実装することができます。おすすめはRust、Zig、C++です。特にRustはOS開発に便利な機能が多く面白い題材です。

[Go](https://wiki.osdev.org/Go_Bare_Bones)などのGC付き言語でも実装できないことはないですが、言語ランタイムライブラリの挙動をしっかり理解する必要があるため少し難易度が上がります。

### OSパーソナリティの実装

他のOSのアプリケーションをHinaOS上で動かしてみましょう。たとえば、API互換のライブラリを実装したり、システムコールをフックしてLinuxのシステムコールのエミュレーションを実装したりといくつか方法があります。

### 他のCPUアーキテクチャへの移植

HinaOSは[QEMUのvirtマシン](https://www.qemu.org/docs/master/system/riscv/virt.html) (32ビットRISC-V CPU) のみ対応していますが、他のCPUへ移植しやすいような実装になっています。

おすすめ、Webや書籍に情報がたくさんある x86-64 CPUへの移植です。RISC-Vに比べかなり複雑ではありますが、その分面白いでしょう。

### 実機への移植

RISC-Vの実機を購入し、HinaOSで動くようにしてみましょう。[秋月電子通商](https://akizukidenshi.com/catalog/c/crisc-v/)や[スイッチサイエンス](https://www.switch-science.com/collections/all/cat:%E3%83%81%E3%83%83%E3%83%97%2F%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3_RISC-V)でいくつかRISC-V搭載のボードが販売されています。

ボードによって、シリアルポートの制御方法や物理メモリ領域の構成が異なるため、各ボードの仕様書を読みながら移植を進めていく必要があります。

### クラウド上でOSを動かしてみる

「HTTPサーバの実装」と「他のCPUアーキテクチャへの移植 (x86-64)」を完了したら、クラウド上でOSを動かしてみましょう。一般的なIaaSでは、x86-64 CPUの仮想マシンが提供されているためHTTPサーバの実装だけでなく、x86-64への移植とネットワークデバイスドライバ (virtio-net) も必要になります。

筆者の知る限り、以下のサービスで自作OSを動かすことができます。

- [さくらのクラウド](https://cloud.sakura.ad.jp/): [ISOイメージ](https://manual.sakura.ad.jp/cloud/storage/isoimage.html)をアップロードすることで自作OSを起動できる。
- [Google Compute Engine](https://cloud.google.com/compute): VMの環境情報が[ココ](https://cloud.google.com/compute/docs/images/building-custom-os)にまとまっている。
- [DigitalOcean](https://www.digitalocean.com/): OSの種類を「Unknown」にしてDropletを作成すると、DHCPサーバが応答するようになる。[詳しくはこちら](https://seiya.me/blog/this-website-is-now-powered-by-kerla)。

ただし難易度は非常に高いです。デバッグ手段が非常に限られているのと、クラウド上でしか再現しないバグがあるため、勘デバッグ力が必要です。また、ビルド・デプロイに時間がかかるため非常に億劫なテーマです。しかし、その努力に見合うだけの面白さは確かにあります。
